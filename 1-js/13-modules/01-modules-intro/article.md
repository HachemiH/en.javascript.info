
# Modules, introduction

Au fur et √† mesure que notre application grandit, nous souhaitons la scinder en plusieurs fichiers, appel√©s "modules". Un module contient g√©n√©ralement une classe ou une biblioth√®que de fonctions pour une t√¢che pr√©cise.

Pendant longtemps, JavaScript n'avait pas de module. Ce n‚Äô√©tait pas un probl√®me, car au d√©part les scripts √©taient petits et simples, il n‚Äô√©tait donc pas n√©cessaire.

Mais les scripts sont devenus de plus en plus complexes et la communaut√© a donc invent√© diverses m√©thodes pour organiser le code en modules, des biblioth√®ques sp√©ciales pour charger des modules √† la demande.

Pour en nommer quelques-uns (pour des raisons historiques) :

- [AMD](https://en.wikipedia.org/wiki/Asynchronous_module_definition) -- un des syst√®mes de modules les plus anciens, initialement mis en ≈ìuvre par la biblioth√®que [require.js](http://requirejs.org/).
- [CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1) -- le syst√®me de module cr√©√© pour Node.js
- [UMD](https://github.com/umdjs/umd) -- un syst√®me de module suppl√©mentaire, propos√© comme universel, compatible avec AMD et CommonJS

Maintenant, tous ces √©l√©ments deviennent lentement du pass√©, mais nous pouvons toujours les trouver dans d‚Äôanciens scripts.

Le syst√®me de modules au niveau du langage est apparu dans la norme en 2015, a progressivement √©volu√© depuis, et est d√©sormais pris en charge par tous les principaux navigateurs et dans Node.js. Nous allons donc √©tudier les modules JavaScript modernes √† partir de maintenant.

## Qu'est-ce qu'un module?

Un module n'est qu'un fichier. Un script est un module. Aussi simple que cela.

Les modules peuvent se charger mutuellement et utiliser des directives sp√©ciales, `export` et `import`, pour √©changer des fonctionnalit√©s, appeler les fonctions d‚Äôun module dans un autre:

- Le mot-cl√© `export` labelise les variables et les fonctions qui doivent √™tre accessibles depuis l'ext√©rieur du module actuel.
- `import` permet l'importation de fonctionnalit√©s √† partir d'autres modules.

Par exemple, si nous avons un fichier `sayHi.js` exportant une fonction

```js
// üìÅ sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
```

...Un autre fichier peut l'importer et l'utiliser:

```js
// üìÅ main.js
import {sayHi} from './sayHi.js';

alert(sayHi); // function...
sayHi('John'); // Hello, John!
```

La directive `import` charge le module qui a pour chemin `./sayHi.js` par rapport au fichier actuel et affecte la fonction export√©e `sayHi` √† la variable correspondante.

Lan√ßons l‚Äôexemple dans le navigateur.

Comme les modules prennent en charge des mots-cl√©s et des fonctionnalit√©s sp√©ciales, nous devons indiquer au navigateur qu'un script doit √™tre trait√© comme un module, en utilisant l'attribut `<script type="module">`.

Comme √ßa:

[codetabs src="say" height="140" current="index.html"]

Le navigateur extrait et √©value automatiquement le module import√© (et, le cas √©ch√©ant, ses importations), puis ex√©cute le script.

<<<<<<< HEAD
```warn header="Les modules fonctionnent uniquement via HTTP(s), pas dans des fichiers locaux"
Si vous essayez d'ouvrir une page Web localement, via le protocole `file: //`, vous verrez que les directives `import / export` ne fonctionnent pas. Utilisez un serveur Web local, tel que [static-server](https://www.npmjs.com/package/static-server#getting-started) ou utilisez la fonctionnalit√© "live server" de votre √©diteur, telle que VS Code [Live Server Extension](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) pour tester les modules.
=======
```warn header="Modules work only via HTTP(s), not locally"
If you try to open a web-page locally, via `file://` protocol, you'll find that `import/export` directives don't work. Use a local web-server, such as [static-server](https://www.npmjs.com/package/static-server#getting-started) or use the "live server" capability of your editor, such as VS Code [Live Server Extension](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) to test modules.
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c
```

## Caract√©ristiques du module de base

Qu'est-ce qui est diff√©rent dans les modules par rapport aux scripts "normaux"?

Il existe des fonctionnalit√©s de base, valables √† la fois pour le navigateur et le JavaScript c√¥t√© serveur.

### Toujours en mode "use strict"

<<<<<<< HEAD
Les modules utilisent `use strict`, par d√©faut. Par exemple. assigner √† une variable non d√©clar√©e donnera une erreur.
=======
Modules always work in strict mode. E.g. assigning to an undeclared variable will give an error.
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

```html run
<script type="module">
  a = 5; // error
</script>
```

### Port√©e au niveau du module

Chaque module a sa propre port√©e globale. En d'autres termes, les variables et les fonctions globales d'un module ne sont pas visibles dans les autres scripts.

<<<<<<< HEAD
Dans l'exemple ci-dessous, deux scripts sont import√©s et `hello.js` essaie d'utiliser la variable `user` d√©clar√©e dans `user.js` et √©choue:

[codetabs src="scopes" height="140" current="index.html"]

Les modules sont cens√©s `export` ce qui doit √™tre accessible de l'ext√©rieur et `import` ce dont ils ont besoin.

Nous devons donc importer `user.js` dans `hello.js` et en tirer les fonctionnalit√©s requises au lieu de nous fier √† des variables globales.
=======
In the example below, two scripts are imported, and `hello.js` tries to use `user` variable declared in `user.js`. It fails, because it's a separate module (you'll see the error in the console):

[codetabs src="scopes" height="140" current="index.html"]

Modules should `export` what they want to be accessible from outside and `import` what they need.

- `user.js` should export the `user` variable.
- `hello.js` should import it from `user.js` module.

In other words, with modules we use import/export instead of relying on global variables.
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

Ceci est la bonne variante :

[codetabs src="scopes-working" height="140" current="hello.js"]

<<<<<<< HEAD
Dans le navigateur, un environnement ind√©pendant existe √©galement pour chaque `<script type ="module">`:
=======
In the browser, if we talk about HTML pages, independent top-level scope also exists for each `<script type="module">`.

Here are two scripts on the same page, both `type="module"`. They don't see each other's top-level variables:
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

```html run
<script type="module">
  // La variable est uniquement visible dans ce module
  let user = "John";
</script>

<script type="module">
  *!*
  alert(user); // Error: user is not defined
  */!*
</script>
```

<<<<<<< HEAD
Si nous devons r√©ellement cr√©er une variable globale, nous pouvons l‚Äôaffecter explicitement √† `window` et y acc√©der en tant que `window.user`. Mais c‚Äôest une exception qui n√©cessite une bonne raison.
=======
```smart
In the browser, we can make a variable window-level global by explicitly assigning it to a `window` property, e.g. `window.user = "John"`. 

Then all scripts will see it, both with `type="module"` and without it. 

That said, making such global variables is frowned upon. Please try to avoid them.
```
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

### Un code de module est charg√© la premi√®re fois lorsqu'il est import√©

<<<<<<< HEAD
Si le m√™me module est import√© dans plusieurs autres emplacements, son code n'est ex√©cut√© que la premi√®re fois, puis les exportations sont donn√©es √† tous les importateurs.

Cela a des cons√©quences importantes. Voyons cela sur des exemples.
=======
If the same module is imported into multiple other modules, its code is executed only once, upon the first import. Then its exports are given to all further importers.

The one-time evaluation has important consequences, that we should be aware of. 

Let's see a couple of examples.
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

Premi√®rement, si ex√©cuter un code de module entra√Æne des effets secondaires, comme afficher un message, l'importer plusieurs fois ne le d√©clenchera qu'une seule fois - la premi√®re fois:

```js
// üìÅ alert.js
alert("Module is evaluated!");
```

```js
// Importer le m√™me module √† partir de fichiers diff√©rents

// üìÅ 1.js
import `./alert.js`; // le module est charg√©

// üìÅ 2.js
import `./alert.js`; // (n'affiche rien)
```

<<<<<<< HEAD
En pratique, le code dans l'environnement global du module est principalement utilis√© pour l'initialisation, la cr√©ation de structures de donn√©es internes mais, si nous voulons que quelque chose soit r√©utilisable, exportez-le.

Maintenant, un exemple plus avanc√©.
=======
The second import shows nothing, because the module has already been evaluated.

There's a rule: top-level module code should be used for initialization, creation of module-specific internal data structures. If we need to make something callable multiple times - we should export it as a function, like we did with `sayHi` above.

Now, let's consider a deeper example.
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

Disons qu'un module exporte un objet:

```js
// üìÅ admin.js
export let admin = {
  name: "John"
};
```

Si ce module est import√© √† partir de plusieurs fichiers, il n'est charg√© que la premi√®re fois, un objet `admin` est cr√©√©, puis transmis √† tous les autres importateurs.

Tous les importateurs obtiennent exactement le seul et unique objet `admin`:

```js
// üìÅ 1.js
import {admin} from './admin.js';
admin.name = "Pete";

// üìÅ 2.js
import {admin} from './admin.js';
alert(admin.name); // Pete

*!*
<<<<<<< HEAD
// 1.js et 2.js ont import√© le m√™me objet
// Les modifications apport√©es dans 1.js sont visibles dans 2.js
*/!*
```

Donc, r√©p√©tons-le, le module n‚Äôest ex√©cut√© qu‚Äôune fois. Les exportations sont g√©n√©r√©es, puis partag√©es entre les importateurs. Par cons√©quent, si quelque chose change d'objet `admin`, les autres modules le verront.

Un tel comportement permet de configurer des modules lors de la premi√®re importation. Nous pouvons configurer ses propri√©t√©s une fois, puis dans les importations ult√©rieures, il est pr√™t.

Par exemple, le module `admin.js` peut fournir certaines fonctionnalit√©s, mais attendez-vous √† ce que les informations d'identification entrent dans l'objet `admin` de l'ext√©rieur:
=======
// Both 1.js and 2.js reference the same admin object
// Changes made in 1.js are visible in 2.js
*/!*
```

As you can see, when `1.js` changes the `name` property in the imported `admin`, then `2.js` can see the new `admin.name`.

That's exactly because the module is executed only once. Exports are generated, and then they are shared between importers, so if something changes the `admin` object, other modules will see that.

**Such behavior is actually very convenient, because it allows us to *configure* modules.**

In other words, a module can provide a generic functionality that needs a setup. E.g. authentication needs credentials. Then it can export a configuration object expecting the outer code to assign to it.

Here's the classical pattern:
1. A module exports some means of configuration, e.g. a configuration object.
2. On the first import we initialize it, write to its properties. The top-level application script may do that.
3. Further imports use the module.

For instance, the `admin.js` module may provide certain functionality (e.g. authentication), but expect the credentials to come into the `config` object from outside:
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

```js
// üìÅ admin.js
export let config = { };

export function sayHi() {
  alert(`Ready to serve, ${config.user}!`);
}
```

<<<<<<< HEAD
Dans `init.js`, le premier script de notre application, nous d√©finissons `admin.name`. Ensuite, tout le monde le verra, y compris les appels pass√©s depuis `admin.js` lui-m√™me:
=======
Here, `admin.js` exports the `config` object (initially empty, but may have default properties too).

Then in `init.js`, the first script of our app, we import `config` from it and set `config.user`:
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

```js
// üìÅ init.js
import {config} from './admin.js';
config.user = "Pete";
```

<<<<<<< HEAD
Un autre module peut aussi voir `admin.name`:
=======
...Now the module `admin.js` is configured. 
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c

Further importers can call it, and it correctly shows the current user:

```js
// üìÅ another.js
import {sayHi} from './admin.js';

sayHi(); // Pr√™t √† √™tre utilis√©, *!*Pete*/!*!
```


### import.meta

L'objet `import.meta` contient les informations sur le module actuel.

<<<<<<< HEAD
Son contenu d√©pend de l'environnement. Dans le navigateur, il contient l'URL du script ou une URL de page Web actuelle si elle est en HTML:

```html run height=0
<script type="module">
  alert(import.meta.url); // URL du script (URL de la page HTML)
=======
Its content depends on the environment. In the browser, it contains the URL of the script, or a current webpage URL if inside HTML:

```html run height=0
<script type="module">
  alert(import.meta.url); // script URL
  // for an inline script - the URL of the current HTML-page
>>>>>>> fb4fc33a2234445808100ddc9f5e4dcec8b3d24c
</script>
```

### Dans un module, "this" n'est pas d√©fini

C‚Äôest un peu une caract√©ristique mineure, mais pour √™tre complet, nous devrions le mentionner.

Dans un module, l'objet global `this` est ind√©fini.

Comparez-le √† des scripts sans module, l√† o√π il est un object global:

```html run height=0
<script>
  alert(this); // window
</script>

<script type="module">
  alert(this); // undefined
</script>
```

## Fonctionnalit√©s sp√©cifiques au navigateur

Il existe √©galement plusieurs diff√©rences de scripts sp√©cifiques au navigateur avec `type="module"` par rapport aux scripts classiques.

Vous devriez peut-√™tre ignorer cette section pour l'instant si vous lisez pour la premi√®re fois ou si vous n'utilisez pas JavaScript dans un navigateur.

### Les modules sont diff√©r√©s

Les modules sont *toujours* diff√©r√©s, avec le m√™me effet que l'attribut `defer` (d√©crit dans le chapitre [](info:script-async-defer)), pour les scripts externes et int√©gr√©s.

En d'autres termes:
- t√©l√©charger des modules externe `<script type="module" src="...">` ne bloque pas le traitement HTML, ils se chargent en parall√®le avec d‚Äôautres ressources.
- Les modules attendent que le document HTML soit compl√®tement pr√™t (m√™me s'ils sont minuscules et se chargent plus rapidement que le HTML), puis s'ex√©cutent.
- l'ordre relatif des scripts est maintenu : les scripts qui entrent en premier dans le document sont ex√©cut√©s en premier.

Comme effet secondaire, les modules "voient" toujours la page HTML enti√®rement charg√©e, y compris les √©l√©ments HTML situ√©s en dessous.

Par exemple:

```html run
<script type="module">
*!*
  alert(typeof button); // object: le script peut 'voir' le bouton ci-dessous
*/!*
  // √† mesure que les modules sont diff√©r√©s, le script s'ex√©cute apr√®s le chargement de la page enti√®re
</script>

Comparez au script habituel ci-dessous:

<script>
*!*
  alert(typeof button); // button est undefined, le script ne peut pas voir les √©l√©ments ci-dessous
*/!*
  // les scripts normaux sont ex√©cut√©s imm√©diatement, avant que le reste de la page ne soit trait√©
</script>

<button id="button">Button</button>
```

Remarque : le deuxi√®me script fonctionne avant le premier ! Nous verrons donc d'abord `undefined`, puis `object`.

C‚Äôest parce que les modules sont diff√©r√©s, nous attendons donc que le document soit trait√©. Les scripts r√©guliers s'ex√©cutent imm√©diatement, nous avons donc vu son resultat en premier.

Lorsque nous utilisons des modules, nous devons savoir que la page HTML appara√Æt lors de son chargement et que les modules JavaScript s'ex√©cutent par la suite, afin que l'utilisateur puisse voir la page avant que l'application JavaScript soit pr√™te. Certaines fonctionnalit√©s peuvent ne pas encore fonctionner. Nous devons d√©finir des "indicateurs de chargement" ou veiller √† ce que le visiteur ne soit pas confus par cela.

### Async fonctionne sur les scripts en ligne

Pour les scripts non modulaires, l'attribut `async` ne fonctionne que sur les scripts externes. Les scripts asynchrones s'ex√©cutent imm√©diatement lorsqu'ils sont pr√™ts, ind√©pendamment des autres scripts ou du document HTML.

Pour les modules, cela fonctionne sur tous les scripts.

Par exemple, le script ci-dessous est `async` et n‚Äôattend donc personne.

Il effectue l'importation (r√©cup√®re `./analytics.js`) et s'ex√©cute lorsqu'il est pr√™t, m√™me si le document HTML n'est pas encore termin√© ou si d'autres scripts sont toujours en attente.

C‚Äôest bon pour une fonctionnalit√© qui ne d√©pend de rien, comme des compteurs, des annonces, des √©couteurs d‚Äô√©v√©nements au niveau du document.

```html
<!-- toutes les d√©pendances sont r√©cup√©r√©es (analytics.js) et le script s'ex√©cute -->
<!-- il n'attend pas le document ou d'autres balises <script> -->
<script *!*async*/!* type="module">
  import {counter} from './analytics.js';

  counter.count();
</script>
```

### Scripts externes

Les scripts externes de `type="module"` se distinguent sous deux aspects:

1. Les scripts externes avec le m√™me `src` ne s'ex√©cutent qu'une fois:
    ```html
    <!-- le script my.js est r√©cup√©r√© et ex√©cut√© une seule fois -->
    <script type="module" src="my.js"></script>
    <script type="module" src="my.js"></script>
    ```

2. Les scripts externes extraits d‚Äôune autre origine (par exemple, un autre site) n√©cessitent [CORS](https://developer.mozilla.org/fr/docs/Web/HTTP/CORS) en-t√™tes, comme d√©crit dans le chapitre <info:fetch-crossorigin>. En d'autres termes, si un module est extrait d'une autre origine, le serveur distant doit fournir un en-t√™te `Access-Control-Allow-Origin` permettant l'extraction.
    ```html
    <!-- another-site.com doit fournir Access-Control-Allow-Origin -->
    <!-- sino, le script ne sera pas ex√©cut√© -->
    <script type="module" src="*!*http://another-site.com/their.js*/!*"></script>
    ```

    Cela garantit une meilleure s√©curit√© par d√©faut.

### Aucun module "nu" autoris√©

Dans le navigateur, `import` doit avoir une URL relative ou absolue. Les modules sans chemin sont appel√©s modules "nus". De tels modules ne sont pas autoris√©s lors de l'importation.

Par exemple, cette `import` n'est pas valide:
```js
import {sayHi} from 'sayHi'; // Error, "bare" module
// le module doit avoir un chemin, par exemple './sayHi.js'
```

Certains environnements, tels que Node.js ou les outils de bundle autorisent les modules nus, sans chemin d'acc√®s, car ils disposent de moyens propres de recherche de modules trouver des modules et des hooks pour les ajuster. Mais les navigateurs ne supportent pas encore les modules nus.

### Compatibilit√©, ‚Äúnomodule‚Äù

Les anciens navigateurs ne comprennent pas `type="module"`. Les scripts de type inconnu sont simplement ignor√©s. Pour eux, il est possible de fournir une solution de secours en utilisant l‚Äôattribut `nomodule` :

```html run
<script type="module">
  alert("Runs in modern browsers");
</script>

<script nomodule>
  alert("Modern browsers know both type=module and nomodule, so skip this")
  alert("Old browsers ignore script with unknown type=module, but execute this.");
</script>
```

## Construire des outils

Dans la vie r√©elle, les modules de navigateur sont rarement utilis√©s sous leur forme "brute". G√©n√©ralement, nous les regroupons avec un bundle tel que [Webpack](https://webpack.js.org/) et les d√©ployons sur le serveur de production.

L'un des avantages de l'utilisation des bundles est -- qu'ils permettent de mieux contr√¥ler la fa√ßon dont les modules sont r√©solus, permettant ainsi des modules nus et bien plus encore, comme les modules CSS / HTML.

Les outils de construction font ce qui suit:

1. Prenons un module "principal", celui qui est destin√© √† √™tre plac√© dans `<script type="module">` dans le HTML.
2. Analyser ses d√©pendances : importations puis importations d'importations etc.
3. Construire un seul fichier avec tous les modules (ou plusieurs fichiers configurables), en rempla√ßant les appels `import` natifs par des fonctions d‚Äôassemblage, pour que cela fonctionne. Les types de modules "sp√©ciaux" tels que les modules HTML/CSS sont √©galement pris en charge.
4. Dans le processus, d'autres transformations et optimisations peuvent √™tre appliqu√©es:
    - Le code inaccessible est supprim√©.
    - Les exportations non utilis√©es sont supprim√©es ("tree-shaking").
    - Les instructions sp√©cifiques au d√©veloppement telles que `console` et le `debugger` sont supprim√©es.
    - La syntaxe JavaScript moderne et ultramoderne peut √™tre transform√©e en une ancienne version dot√©e de fonctionnalit√©s similaires avec [Babel](https://babeljs.io/).
    - Le fichier r√©sultant est minifi√© (espaces supprim√©s, variables remplac√©es par des noms plus courts, etc.).

Si nous utilisons des outils d'ensemble, alors que les scripts sont regroup√©s dans un seul fichier (ou quelques fichiers), les instructions `import/export` contenues dans ces scripts sont remplac√©es par des fonctions sp√©ciales de regroupeur. Ainsi, le script "fourni" r√©sultant ne contient aucune `import/export`, il ne n√©cessite pas `type="module"`, et nous pouvons le mettre dans un script standard:

```html
<!-- En supposant que nous ayons bundle.js d'un outil tel que Webpack -->
<script src="bundle.js"></script>
```

Cela dit, les modules natifs sont √©galement utilisables. Nous n‚Äôutilisons donc pas Webpack ici: vous pourrez le configurer plus tard.

## Sommaire

Pour r√©sumer, les concepts de base sont les suivants:

1. Un module est un fichier. Pour que `import/export` fonctionne, les navigateurs ont besoin de `<script type="module">`. Les modules ont plusieurs diff√©rences:
    - Diff√©r√© par d√©faut.
    - Async fonctionne sur les scripts en ligne.
    - Pour charger des scripts externes d'une autre origine (domain/protocol/port), des en-t√™tes CORS sont n√©cessaires.
    - Les scripts externes en double sont ignor√©s.
2. Les modules ont leur propre port√©e globale et leurs fonctionnalit√©s d‚Äô√©change via `import/export`.
3. Les modules utilisent toujours `use strict`.
4. Le code des modules est ex√©cut√© une seule fois. Les exportations sont cr√©√©es une fois et partag√©es entre les importateurs

Lorsque nous utilisons des modules, chaque module impl√©mente la fonctionnalit√© et l'exporte. Nous utilisons ensuite `import` pour l‚Äôimporter directement l√† o√π il le faut. Le navigateur charge et ex√©cute les scripts automatiquement.

En production, les gens utilisent souvent des "bundlers" tels que [Webpack](https://webpack.js.org) qui regroupe des modules pour des raisons de performances ou pour d‚Äôautres raisons.

Dans le chapitre suivant, nous verrons plus d‚Äôexemples de modules et comment des choses peuvent √™tre import√© / export√©.
